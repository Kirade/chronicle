# SwiftUI Property Wrapper 완벽 가이드

## 📚 학습 날짜: 2025.08.30

## 1. Property Wrapper란?

Property Wrapper는 변수에 "특별한 능력"을 부여하는 Swift의 기능입니다.

```swift
// 일반 변수
private var normalItem: String = ""

// Property Wrapper를 사용한 변수
@State private var item: String = ""  // 값이 변경되면 View를 다시 그림
```

### 핵심 특징
- `@` 기호로 시작
- 변수의 저장과 접근 방식을 커스터마이징
- SwiftUI에서 View와 데이터를 연결하는 핵심 메커니즘

## 2. SwiftUI View의 동작 원리

### View는 불변(Immutable) 구조체

```swift
struct TestView: View {
    // ❌ 컴파일 에러: struct 내부에서 직접 값 변경 불가
    private var counter: Int = 0

    var body: some View {
        Button("증가") {
            counter += 1  // Error: Cannot assign to property
        }
    }
}
```

### SwiftUI의 렌더링 사이클

```
1. @State 값 변경
   ↓
2. SwiftUI가 변경 감지
   ↓
3. body 다시 호출
   ↓
4. 이전 View와 새 View 비교
   ↓
5. 변경된 부분만 화면 업데이트
```

### View와 State Storage의 분리

```
View Struct (임시, 가벼움)
    ↓ 참조
State Storage (영구적, SwiftUI가 관리)
    - 실제 데이터가 저장되는 곳
    - View가 재생성되어도 값 유지
```

## 3. 주요 Property Wrapper 상세 분석

### @State

**목적**: View가 소유하고 관리하는 로컬 상태

```swift
@State private var text: String = "Hello"
@State private var count: Int = 0
```

**특징**:
- 초기값 필수
- View 내부에서만 사용
- 값 변경 시 자동으로 View 업데이트
- `$` 프리픽스로 양방향 바인딩 제공

**내부 동작**:
```swift
// @State는 실제로 3가지 접근 방법 제공
@State private var counter = 0

// 1. counter → 실제 값 (Int)
// 2. _counter → State<Int> wrapper 인스턴스
// 3. $counter → Binding<Int> 양방향 바인딩
```

### @Environment

**목적**: 시스템이나 부모 View가 제공하는 환경 값 접근

```swift
@Environment(\.modelContext) private var modelContext
@Environment(\.dismiss) private var dismiss
@Environment(\.colorScheme) private var colorScheme
```

**특징**:
- KeyPath를 통해 원하는 값 지정
- 초기값 설정 불가 (시스템이 제공)
- 괄호 안에 KeyPath 전달

**KeyPath 문법**:
```swift
// \.modelContext는 KeyPath<EnvironmentValues, ModelContext>를 의미
// 백슬래시(\)와 점(.)으로 시작하는 특별한 문법
```

### @Query

**목적**: SwiftData에서 자동으로 데이터 가져오기

```swift
@Query private var items: [Item]
@Query(sort: \.timestamp) private var sortedItems: [Item]
```

**특징**:
- 초기값 불필요 (데이터베이스가 자동 제공)
- 데이터 변경 시 자동 업데이트
- 정렬, 필터 등 옵션 가능

### @FocusState

**목적**: 텍스트 필드의 포커스 상태 관리

```swift
// Bool 방식 (단일 필드)
@FocusState private var isFocused: Bool

// Enum 방식 (다중 필드)
enum Field {
    case username
    case password
}
@FocusState private var focusedField: Field?
```

**특징**:
- Bool 또는 Optional Enum 타입
- 키보드 포커스 제어
- nil = 포커스 해제 (키보드 숨김)

**사용 예제**:
```swift
TextField("Username", text: $username)
    .focused($focusedField, equals: .username)

Button("키보드 숨기기") {
    focusedField = nil  // 포커스 해제
}
```

## 4. Property Wrapper 초기화 패턴

### 패턴 1: 초기값 직접 할당
```swift
@State private var text: String = "Hello"
// 컴파일러가 자동으로 init(wrappedValue:) 호출
```

### 패턴 2: 파라미터 전달
```swift
@Environment(\.modelContext) private var context
// init(_ keyPath:) 호출
```

### 패턴 3: 복합 초기화
```swift
// 커스텀 Property Wrapper 예제
@propertyWrapper
struct Limited {
    init(wrappedValue: String = "", _ maxLength: Int) {
        // wrappedValue와 추가 파라미터 모두 받음
    }
}

@Limited(10) var text: String = "Hello"  // 초기값과 제한 길이
```

## 5. 실전 예제 분석

### 제공된 Grocery List 앱 코드

```swift
struct ContentView: View {
    // 시스템 환경에서 ModelContext 가져오기
    @Environment(\.modelContext) private var modelContext

    // 데이터베이스에서 Item 목록 자동 조회
    @Query private var items: [Item]

    // 사용자 입력을 위한 로컬 상태
    @State private var item: String = ""

    // TextField 포커스 관리
    @FocusState private var isFocused: Bool

    var body: some View {
        // ...
        TextField("", text: $item)  // $로 양방향 바인딩
            .focused($isFocused)     // 포커스 상태 연결

        Button {
            // 버튼 액션에서 포커스 해제
            isFocused = false
        }
    }
}
```

## 6. 핵심 개념 정리

### View Protocol과 some View

```swift
struct MyView: View {  // View 프로토콜 채택
    var body: some View {  // 계산 프로퍼티
        Text("Hello")      // 실제 반환 타입은 Text
    }
}
```

- `some View`: "어떤 View 타입인데, 컴파일러가 추론"
- 복잡한 View 조합의 타입을 간단하게 표현

### $ 프리픽스의 의미

```swift
@State private var text = ""

// text → String (실제 값)
// $text → Binding<String> (양방향 바인딩)

TextField("", text: $text)  // TextField가 값을 읽고 쓸 수 있음
```

### nil in Optional FocusState

```swift
@FocusState private var field: Field?

// nil의 의미:
// - "우리가 관리하는 필드 중 아무것도 포커스되지 않은 상태"
// - 키보드 숨기기
// - 관리 대상이 아닌 필드가 포커스를 받은 경우
```

## 7. 학습 요약

### Property Wrapper가 해결하는 문제들

1. **상태 관리**: View는 불변이지만 상태는 변경 가능해야 함
2. **데이터 동기화**: 데이터 변경 시 자동 UI 업데이트
3. **환경 공유**: 부모-자식 View 간 데이터 전달
4. **시스템 통합**: 포커스, 데이터베이스 등과 연동

### 각 Property Wrapper의 데이터 출처

| Property Wrapper | 데이터 출처 | 초기값 | 용도 |
|-----------------|------------|--------|------|
| @State | 우리가 생성/관리 | 필수 | 로컬 상태 |
| @Environment | 시스템/부모 View | 불가 | 환경 값 접근 |
| @Query | 데이터베이스 | 불가 | 데이터 자동 조회 |
| @FocusState | 시스템 추적 | 불가 | 포커스 제어 |

## 8. 추가 학습 자료

- [Apple Developer Documentation - Property Wrappers](https://docs.swift.org/swift-book/LanguageGuide/Properties.html#ID617)
- [SwiftUI Property Wrappers](https://developer.apple.com/documentation/swiftui/state-and-data-flow)
- [SwiftData @Query](https://developer.apple.com/documentation/swiftdata/query)

---

*이 문서는 SwiftUI Property Wrapper에 대한 심층 학습 세션의 정리입니다.*
*실제 코드와 실험을 통해 각 개념을 탐구하고 이해했습니다.*

# iOS Paws 앱 학습 노트
## 📅 2025.08.30

---

## 📱 프로젝트 개요
SwiftUI와 SwiftData를 활용한 펫 관리 앱

---

## 📚 학습한 주요 개념들

### 1. Pet.swift - 데이터 모델

#### `final class`
- **역할**: 클래스가 상속되지 않음을 명시
- **사용 이유**:
  - SwiftData 모델은 일반적으로 상속하지 않음
  - 컴파일러 최적화로 성능 향상

#### `@Attribute(.externalStorage)`
- **역할**: 큰 데이터를 데이터베이스 외부에 저장
- **동작 방식**:
  - 실제 데이터는 파일 시스템에 저장
  - 데이터베이스에는 위치 정보만 저장
  - 접근 시 자동으로 실제 데이터 로드
- **다른 옵션들**:
  - `.unique`: 중복 불가 값
  - `.encrypt`: 암호화 저장
  - `.spotlight`: iOS 검색에 포함

#### `extension`
- **역할**: 기존 타입에 기능 추가
- **가능한 것들**:
  - 메서드 추가 ✅
  - 계산 프로퍼티 추가 ✅
  - 이니셜라이저 추가 ✅
- **불가능한 것**:
  - 저장 프로퍼티 추가 ❌ (초기화 시점 문제)

#### `@MainActor`
- **역할**: 메인 스레드에서 실행 보장
- **필요한 경우**:
  - UI 업데이트 관련 코드
  - mainContext 사용 시
- **스레드 개념**:
  - 메인 스레드: UI, 사용자 상호작용
  - 백그라운드 스레드: 무거운 작업, 네트워크

#### `ModelConfiguration`
- **역할**: SwiftData 저장 방식 설정
- **주요 옵션**:
  - `isStoredInMemoryOnly`:
    - `true`: 메모리에만 저장 (Preview용)
    - `false`: 디스크에 영구 저장 (실제 앱)

---

### 2. CustomContentUnavailableView.swift

#### `ContentUnavailableView` 문법
```swift
ContentUnavailableView {
    // label 클로저
} description: {
    // description 클로저
}
```
- **특징**: 여러 클로저를 받는 SwiftUI 패턴
- **첫 번째 클로저**: 레이블 생략 가능 (Trailing Closure)

#### `@ViewBuilder`
- **역할**: 여러 View를 하나로 자동 결합
- **동작**: 나열된 View들을 TupleView로 묶음

#### Generic 타입
```swift
ContentUnavailableView<Label, Description>
```
- **Label, Description**: 구체적 타입이 아닌 플레이스홀더
- **사용 시점에 타입 결정**: Image, Text 등

---

### 3. ContentView.swift

#### Property Wrapper 접근 제어자
```swift
@Environment(\.modelContext) var modelContext  // private 없음
@Query private var pets: [Pet]                 // private 있음
```
- **Environment**: 각 View가 독립적으로 SwiftUI로부터 주입받음
- **Query**: View별 고유한 조회 결과

#### `@State`
- **역할**: View의 상태 관리
- **특징**:
  - 값을 View 외부 저장소에 보관
  - 값 변경 시 View 자동 재렌더링
  - struct의 불변성 문제 해결

#### NavigationStack과 path
```swift
@State private var path = [Pet]()
NavigationStack(path: $path) { ... }
```
- **path 배열**: 네비게이션 스택 상태
  - `[]`: 메인 화면
  - `[pet1]`: 메인 + pet1 상세 화면
  - `[pet1, pet2]`: 메인 + pet1 + pet2
- **네비게이션 제어 방법**:
  1. NavigationLink 탭
  2. path 직접 조작

#### NavigationLink와 navigationDestination
```swift
NavigationLink(value: pet) { ... }  // 버튼 역할
.navigationDestination(for: Pet.self) { ... }  // 규칙 정의
```
- **관계**: 세트로 동작
- **NavigationLink**: 값을 전달
- **navigationDestination**: 타입별 목적지 View 정의

#### View Modifier 위치
```swift
NavigationStack {
    ScrollView { ... }
        .navigationTitle("Paws")  // ScrollView에 적용
}
```
- **이유**: NavigationStack은 컨테이너, 실제 콘텐츠는 내부 View

#### LazyVGrid
```swift
let layout = [
    GridItem(.flexible(minimum: 120)),  // 첫 번째 열
    GridItem(.flexible(minimum: 120))   // 두 번째 열
]
```
- **GridItem 개수 = 열 개수**
- **flexible**: 최소값 보장, 공간 있으면 확장
- **Lazy**: 화면에 보이는 것만 렌더링 (성능 최적화)

#### ForEach 문법
```swift
ForEach(pets) { pet in
    NavigationLink(value: pet) { ... }
}
```
- **구조**: SwiftUI View를 생성하는 구조체
- **클로저 문법**:
  - `pet`: 각 요소의 이름
  - `in`: 구분 키워드
  - 본문: 각 요소로 생성할 View

#### overlay vs 조건부 렌더링
```swift
.overlay {
    if pets.isEmpty {
        CustomContentUnavailableView(...)
    }
}
```
- **overlay 장점**:
  - 기본 View 구조 유지
  - 부드러운 전환 애니메이션
  - toolbar 등 modifier 일관성

---

## 💡 핵심 학습 포인트

### 스레드와 동시성
- **Main Thread**: UI 작업 전용
- **Background Thread**: 무거운 작업용
- **@MainActor**: 메인 스레드 실행 보장
- **Task**: 비동기 작업 시작 (async/await)

### SwiftData 아키텍처
- **ModelContainer**: 데이터베이스 컨테이너
- **ModelContext**: 데이터 작업 공간
- **mainContext**: 메인 스레드용 context
- **@Query**: 데이터 자동 조회 및 동기화

### SwiftUI 패턴
- **Property Wrapper**: 특별한 동작 추가
- **Trailing Closure**: 가독성 향상
- **ViewBuilder**: 선언적 UI 구성
- **Generic**: 재사용 가능한 컴포넌트

---

## 🎯 다음 학습 제안

### 미니 챌린지
1. **쉬움**: Pet에 생일 추가 (DatePicker)
2. **중간**: 펫 종류별 필터링 (Picker, 상태 관리)
3. **어려움**: 펫 산책 기록 (List, Chart)

### 학습 전략
- 작은 기능부터 구현하며 필요한 컴포넌트 학습
- 에러 발생 시 원인 파악하며 개념 이해
- 공식 문서와 실습 병행

---

## 📝 메모
- `private` 사용의 일관성 고려
- Preview에서 레이아웃 디버깅 활용
- 실제 앱과 Preview의 차이점 이해

---

*이 문서는 2025년 8월 30일 iOS 개발 학습 내용을 정리한 것입니다.*
