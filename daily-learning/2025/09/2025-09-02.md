# SwiftUI Watchlist 앱 학습 노트

## 📚 학습 개요
SwiftUI와 SwiftData를 사용한 영화 목록 관리 앱 코드 분석 및 개념 학습

## 1. Enum과 프로토콜 (Genre.swift)

### Enum의 원시값(Raw Value)
- **정의**: enum의 각 case에 연결된 기본 타입의 고정된 값
- **특징**:
  - 컴파일 시점에 정해지며 변경 불가
  - Int, String 등은 값 생략 시 자동 할당
  - 양방향 변환 가능 (`Genre.action.rawValue` ↔ `Genre(rawValue: 1)`)

### Genre enum이 채택한 프로토콜들

#### 1. Int (Raw Value Type)
```swift
enum Genre: Int {
    case action = 1
    case comedy = 2
}
```
- 데이터베이스 저장 시 효율적 (정수로 저장)
- JSON 변환 시 숫자로 표현

#### 2. Codable (Encodable + Decodable)
- **용도**: JSON, PropertyList 등으로 자동 변환
- **SwiftData에서 필수인 이유**:
  - 데이터를 직렬화(serialize)해서 저장하기 위함
  - 복잡한 타입의 인코딩/디코딩 규칙 제공
  - Int 원시값이 있으면 자동으로 정수로 변환

#### 3. CaseIterable
```swift
Genre.allCases // 모든 case를 배열로 자동 생성
```
- Picker, List 등 UI 구성 시 유용
- 새 case 추가 시 자동으로 `allCases`에 포함

#### 4. Identifiable
```swift
var id: Int { rawValue }
```
- SwiftUI의 ForEach, List에서 각 항목 구별
- `id` 지정 없이 ForEach 사용 가능

### 프로토콜 채택 시점 전략

**선제적 설계 (Proactive)**
- ✅ Codable: 데이터 모델용이면 미리 추가
- 일관성 있는 코드, 팀 협업 시 명확

**필요 시 추가 (Reactive)**
- CaseIterable, Identifiable: UI 작성 시 필요하면 추가
- YAGNI 원칙, 과도한 설계 방지

## 2. 컴포넌트 분리와 재사용성

### 컴포넌트 분리 기준
1. **재사용 횟수**: 2번 이상 사용되면 분리 고려
2. **가독성**: 파일이 너무 복잡해지면 분리
3. **응집도**: 관련 기능끼리 묶기

### ButtonImageView vs PageTabView
- **ButtonImageView**: 여러 곳에서 재사용 → Components 폴더 적절
- **PageTabView**: EmptyListView 전용 → private struct로도 충분

### 네이밍 전략
```swift
// 범용적 이름 (재사용 가능)
CircularButton, RoundIconButton

// 특정 용도 이름 (제한적 사용)
OnboardingStepView, TutorialStep
```

### 컴포넌트 진화 과정
```swift
// 1. 처음: private으로 시작
private struct PageTabView: View { }

// 2. 재사용 필요 시: 공용 컴포넌트로 리팩토링
// Components/OnboardingStepView.swift
```

## 3. View의 확장과 파급 효과

### Movie 모델 확장 시 고려사항
```swift
// 기존
@Model
final class Movie {
    var title: String
    var genre: Genre
}

// 확장 (예: 평점 추가)
@Model
final class Movie {
    var title: String
    var genre: Genre
    var rating: Int?  // 추가
}
```

### 파급 효과 (Ripple Effect)
Model 변경 → View 수정 → Form 수정 → ...

### 해결 방안들

#### 1. 전용 View 컴포넌트
```swift
struct MovieRowView: View {
    let movie: Movie
    // Movie 표시 로직 캡슐화
}
```

#### 2. Display Mode Pattern (Enum)
```swift
enum MovieRowDisplayMode {
    case normal
    case friendWatched(String)
    case onSale(price: String)
}
```
**한계**: 조합이 필요한 경우 처리 어려움

#### 3. Context/Configuration Pattern
```swift
struct MovieRowContext {
    let movie: Movie
    let isNew: Bool = false
    let salePrice: String? = nil
    // 여러 속성 동시 설정 가능
}
```

## 4. SwiftUI 환경과 상태 관리

### @Environment(\.dismiss)
- **역할**: 현재 View를 닫는 공통 인터페이스
- **작동 방식**:
  - Sheet → 아래로 내림
  - Navigation → 뒤로 이동
  - Popover → 사라짐

```swift
@Environment(\.dismiss) var dismiss

// 사용
dismiss()  // 표시 방법과 무관하게 동작
```

### Alert와 바인딩
```swift
.alert(randomMovie, isPresented: $isShowingAlert) {
    Button("OK") { }  // 액션 비어있어도 동작
}
```

**SwiftUI의 자동 처리**:
1. 버튼 탭 감지
2. 사용자 액션 코드 실행
3. `isShowingAlert`를 false로 자동 변경
4. Alert 닫기

### sensoryFeedback
- 햅틱 피드백 제공
- `trigger` 값이 변경될 때 진동 발생

## 5. 핵심 개념 정리

### Hashable
- "값을 고유한 숫자로 변환 가능"
- Dictionary key, Set 요소로 사용 가능
- Swift enum은 자동으로 Hashable

### ForEach와 id
```swift
// Identifiable 없을 때
ForEach(Genre.allCases, id: \.self) { }
ForEach(Genre.allCases, id: \.rawValue) { }

// Identifiable 있을 때
ForEach(Genre.allCases) { }  // id 자동 사용
```

### 리팩토링 철학
1. **Make it work** (일단 작동하게)
2. **Make it clean** (깔끔하게 정리)
3. **사후 접근**: 필요성을 느낄 때 분리/개선

## 💡 실무 팁

1. **컴포넌트 분리 시기**: 코드 중복이 2회 이상 발생하거나 파일이 복잡해질 때
2. **프로토콜 채택**: 데이터 모델은 Codable 필수, UI 관련은 필요 시 추가
3. **네이밍**: 범용 컴포넌트는 일반적 이름, 특정 용도는 구체적 이름
4. **확장성 고려**: 미래를 대비하되 과도한 설계는 피하기
5. **응집도 우선**: 관련 코드는 가까이, 재사용 필요 시 분리

## 📝 숙제/생각해볼 문제

1. PageTabView를 OnboardingStepView로 리네이밍하고 재사용 가능하게 만들기
2. Movie 모델에 평점 기능 완전히 구현하기 (입력 UI 포함)
3. MovieRowView를 만들어 다양한 표시 모드 지원하기
4. Genre enum의 오타 수정하고 일관된 대소문자 적용하기

---

*작성일: 2025년 9월 2일*
*학습 앱: SwiftUI Watchlist*
